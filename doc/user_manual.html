<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>RTPProxy 2.2 Manual</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /></head><body><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="idm46526643932496"></a>RTPProxy 2.2 Manual</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Maksym</span> <span class="surname">Sobolyev</span></h3><div class="affiliation"><span class="orgname">Sippy Labs<br /></span></div><code class="email">&lt;<a class="email" href="mailto:sobomax@gmail.com">sobomax@gmail.com</a>&gt;</code></div></div><div><div class="author"><h3 class="author"><span class="surname">Donat Zenichev</span></h3></div></div><div><p class="copyright">Copyright © 2006-20019 Maksym Sobolyev <a class="ulink" href="mailto:sobomax@gmail.com" target="_top">&lt;sobomax@gmail.com&gt;</a></p></div><div><p class="copyright">Copyright © 2019 Donat Zenichev</p></div><div><p class="copyright">Copyright © 2006 Jan Janak <a class="ulink" href="mailto:janakj@users.berlios.de" target="_top">&lt;janakj@users.berlios.de&gt;</a></p></div><div><p class="pubdate">30 May 2019</p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="#idm46526616549712">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idm46526616549040">What is RTPProxy</a></span></dt><dt><span class="section"><a href="#idm46526616546624">Backstory</a></span></dt><dt><span class="section"><a href="#idm46526616540336">Capabilities</a></span></dt><dt><span class="section"><a href="#idm46526616536464">Principles of Operation</a></span></dt><dt><span class="section"><a href="#idm46526616529216">Content of the Package</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm46526616519104">2. Installation of RTPProxy</a></span></dt><dd><dl><dt><span class="section"><a href="#idm46526616518416">Pre-built RTPProxy</a></span></dt><dt><span class="section"><a href="#MAKESRC">Compilation from sources</a></span></dt></dl></dd><dt><span class="chapter"><a href="#idm46526616693792">3. Getting Started</a></span></dt><dt><span class="chapter"><a href="#CONFIGURATION">4. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idm46526611098480">Command Line Parameters</a></span></dt><dt><span class="section"><a href="#idm46526611093984">Configuration File</a></span></dt><dt><span class="section"><a href="#idm46526611092832">Startup Script</a></span></dt><dt><span class="section"><a href="#idm46526611087184">Logging</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm46526616549712"></a>Chapter 1. Introduction</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idm46526616549040">What is RTPProxy</a></span></dt><dt><span class="section"><a href="#idm46526616546624">Backstory</a></span></dt><dt><span class="section"><a href="#idm46526616540336">Capabilities</a></span></dt><dt><span class="section"><a href="#idm46526616536464">Principles of Operation</a></span></dt><dt><span class="section"><a href="#idm46526616529216">Content of the Package</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616549040"></a>What is RTPProxy</h2></div></div></div><p>The RTPProxy is a high-performance software proxy for RTP streams
      that can work together with Sippy B2BUA, Kamailio, OpenSIPs and SER (SIP
      Express Router).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>For the current moment the newest stable version is -
        <span class="emphasis"><em>RTPProxy 2.2</em></span></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616546624"></a>Backstory</h2></div></div></div><p>RTPProxy was originally developed by <span class="authorinitials">Maxim
      Sobolyev</span> in 2003 with a purpose of VoIP calls
      facilitation to/from SIP User Agents located behind NAT or firewalls.
      That time, there were a few cases where direct end-to-end communication
      between users behind the NAT was not possible. RTPProxy, in common with
      a SIP proxy, overcomes those obstacles by acting as an intermediary
      point for the RTP streams.</p><p>Afterwards, the RTPProxy has become widely used by VoIP service
      providers that are in a demand for optimizing a traffic flow in their
      networks.</p><p>Later on it became apparent that there are many other possible
      uses of this software. It can be used in common with a signaling element
      (SIP Proxy or SIP B2BUA) to build complex VoIP networks, to optimize a
      traffic flow, to collect voice quality information and so on.</p><p>RTPProxy is now actively developed and maintained by the <a class="ulink" href="https://sippysoft.com" target="_top"><span class="bold"><strong>Sippy Software,
      Inc</strong></span>.</a> and is available on GitHub of Sippy Labs -
      <a class="ulink" href="https://github.com/sippy/rtpproxy" target="_top">https://github.com/sippy/rtpproxy</a>.</p><p>Over the years, many other individuals and organizations has
      contributed features and fixes into the code base, including Vonage,
      SipPulse, Voicenter, RateTel, either directly or by sponsoring
      respective development efforts (often both).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616540336"></a>Capabilities</h2></div></div></div><p>Originally it was designed for handling of NAT scenarios. It can
      also act as a generic media relay, as well as a gateway for RTP sessions
      between IPv4 and IPv6 networks.</p><p>It can perform number of additional functions on RTP streams,
      including call recording, playing pre-recorded announcements, real-time
      stream copying and RTP payload re-framing.</p><p>The RTPProxy supports some advanced features, such as remote
      control mode, allowing a building of scalable distributed SIP VoIP
      networks. The nathelper module included into the SIP Express Router (now
      known as OpenSIPS or Kamailio, both are forks of SER), as well as Sippy
      B2BUA allow using multiple RTPProxy instances running on remote machines
      for fault-tolerance and load-balancing purposes.</p><p>An advanced high-capacity clustering and a load balancing is
      available through the use of RTP Cluster middleware.</p><p>The software also supports MOH/pre-recorded prompts injection,
      video relaying and RTP session recording to a local file or remote UDP
      listener(s).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616536464"></a>Principles of Operation</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Firstly, when a SIP proxy receives an INVITE request, it
          extracts a call-id from it and hands it to the proxy via Unix domain
          socket. Then, in its turn, a proxy looks for an existing session
          with the same id. If the session exists, it returns a UDP port for
          that session. In case it doesn't exist, it creates a new session and
          binds it to a first empty UDP port from the range specified at the
          start time and returns the number of that port to a SIP proxy called
          it. Upon receiving a reply from the proxy, SIP Proxy (Sippy B2BUA,
          OpenSIPS or Kamailio) in its turn replaces media IP:port in the SDP
          body, in order to point to the media proxy and then it forwards a
          request as usually.</p></li><li class="listitem"><p>When it comes to receiving of non-negative SIP reply with the
          SDP body, then SIP proxy again extracts call-id from it and hands it
          to the rtpproxy. In this case the rtpproxy does not allocate a new
          session, if it doesn't exist. But simply performs a lookup among
          existing sessions and returns either a port number if the session is
          found, or an error code indicating that there is no session with
          such id. Upon receiving a positive reply from the rtpproxy, SIP
          Proxy (Sippy B2BUA, OpenSIPS or Kamailio) replaces media IP:port in
          the SDP body of that SIP reply, in order to point to the rtpproxy
          and then forwards this reply as usually.</p></li><li class="listitem"><p>After the session has been created, the rtpproxy listens on
          the port it has allocated for that session. It also waits for
          receiving at least one UDP packet from each of two parties
          participating in the call. Once such packet was received, the proxy
          fills one of two ip:port structures associated with each call, using
          source ip:port of that packet as a value. When both structures are
          filled in, the proxy starts relaying UDP packets between call
          parties.</p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>A good advantage of the RTPProxy is, that it tracks idle time
        for each existing session (the period of time within which no packets
        were relayed) and automatically cleans up a session, idle time of
        which exceed the value specified at the command line (60 seconds by
        default).</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616529216"></a>Content of the Package</h2></div></div></div><p>The RTPProxy package by default provides the following
      components:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>rtpproxy</strong></span> - main RTP proxy
          server binary (production build)</p></li><li class="listitem"><p><span class="bold"><strong>rtpproxy_debug</strong></span> - Main RTP
          proxy server binary (debug and profiling build)</p></li><li class="listitem"><p><span class="bold"><strong>makeann </strong></span>- Utility to
          pre-encode prompts and announcements (production build)</p></li><li class="listitem"><p><span class="bold"><strong>makeann_debug</strong></span> - Utility to
          pre-encode prompts and announcements (debug and profiling
          build)</p></li><li class="listitem"><p><span class="bold"><strong>extractaudio </strong></span>- Utility to
          convert recorded sessions into plain audio files (production
          build)</p></li><li class="listitem"><p><span class="bold"><strong>extractaudio_debug</strong></span> - Utility
          to convert recorded sessions into plain audio files (debug and
          profiling build)</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm46526616519104"></a>Chapter 2. Installation of RTPProxy</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idm46526616518416">Pre-built RTPProxy</a></span></dt><dt><span class="section"><a href="#MAKESRC">Compilation from sources</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526616518416"></a>Pre-built RTPProxy</h2></div></div></div><p>In case you want to use per-built RTPProxy package, then use your
      system's package manager to set this up:</p><p><span class="application">dpkg</span> - for
      <span class="productname">Debian</span>™ based systems(including
      <span class="productname">Ubuntu</span>™), when installing .deb
      packages.</p><p><span class="application">apt-get</span> / <span class="package">aptitude</span> -
      for <span class="productname">Debian</span>™ based systems (including
      <span class="productname">Ubuntu</span>™), when installing from a
      repository.</p><p><span class="application">rpm</span> - for
      <span class="productname">CentOS</span>™ when installing .rpm packages.</p><p><span class="application">pkg</span> - for
      <span class="productname">FreeBSD</span>™ when installing from a repository or
      packages.</p><p>In case you want to compile RTPProxy from sources, use the
      following section <a class="link" href="#MAKESRC" title="Compilation from sources">"Compilation from
      sources"</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="MAKESRC"></a>Compilation from sources</h2></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm46526612567616"></a>Installing Dependencies</h3></div></div></div><p>The RTPProxy package has several optional dependencies that are
        detected at the configure stage and an appropriate functionality is
        enabled.</p><p>Those dependencies and their impact on the RTPProxy build are
        listed below:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="package">bcg729</span> - Enables G.729 support in several
            tools.</p><p><a class="ulink" href="https://linphone.org/releases/sources/bcg729/" target="_top">https://linphone.org/releases/sources/bcg729/</a></p><p><span class="bold"><strong>Affected binaries:</strong></span>
            <span class="emphasis"><em><span class="command"><strong>extractaudio</strong></span>
            <span class="command"><strong>makeann</strong></span></em></span></p></li><li class="listitem"><p><span class="package">libsndfile</span> - Allows decoded audio to be
            saved in a number of popular audio formats instead of just RAW
            signed-linear 16bit.</p><p><a class="ulink" href="http://www.mega-nerd.com/libsndfile/files/" target="_top">http://www.mega-nerd.com/libsndfile/files/</a></p><p><span class="bold"><strong> Affected binaries:</strong></span>
            <span class="emphasis"><em><span class="command"><strong>extractaudio</strong></span></em></span></p></li><li class="listitem"><p><span class="package">libg722</span> - Enables G.722 support in
            several tools.</p><p><a class="ulink" href="https://github.com/sippy/libg722" target="_top">https://github.com/sippy/libg722</a></p><p><span class="bold"><strong>Affected binaries:</strong></span>
            <span class="emphasis"><em><span class="command"><strong>extractaudio</strong></span>
            <span class="command"><strong>makeann</strong></span></em></span></p></li><li class="listitem"><p><span class="package">libsrtp</span> - Enables decoding recordings of
            SRTP streams.</p><p><a class="ulink" href="https://github.com/cisco/libsrtp.git" target="_top">https://github.com/cisco/libsrtp.git</a></p><p><span class="bold"><strong>Affected binaries:</strong></span>
            <span class="emphasis"><em><span class="command"><strong>extractaudio</strong></span></em></span></p></li><li class="listitem"><p><a id="deps.libelperiodic"></a><span class="package">libelperiodic</span> - Required by several
            internal tools that are used by an automated testing framework.
            Both shared library and python module need to be installed into
            either system location or python environment. <span class="command"><strong>make
            check</strong></span> will fail if it's not installed.</p><p><a class="ulink" href="https://github.com/sobomax/libelperiodic.git" target="_top">https://github.com/sobomax/libelperiodic.git</a></p><p><span class="bold"><strong>Affected tools:</strong></span>
            <span class="emphasis"><em><span class="command"><strong>rtpp_notify_client.py</strong></span>
            <span class="command"><strong>rtpp_query.py</strong></span>
            <span class="command"><strong>getmonotime.py</strong></span></em></span></p></li><li class="listitem"><p><a id="deps.tcpdump"></a><span class="package">tcpdump</span> - Test framework requires it to
            capture traffic and verify PCAP decoding features. <span class="command"><strong>make
            check</strong></span> will fail if it's not installed.</p><p><a class="ulink" href="http://www.tcpdump.org/release/" target="_top">http://www.tcpdump.org/release/</a></p></li><li class="listitem"><p><a id="deps.sudo"></a><span class="package">sudo</span> - Test framework requires it to run
            the <span class="command"><strong>tcpdump</strong></span> at elevated privileges.
            <span class="command"><strong>make check</strong></span> will fail if it's not
            installed.</p><p><a class="ulink" href="http://www.sudo.ws/" target="_top">http://www.sudo.ws/</a></p></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>Do not forget about dependencies required by your
          compiler!</p><p>For e.g. in case you use GCC linux compiler, you need to
          install in advance:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>bison</p></li><li class="listitem"><p>flex</p></li><li class="listitem"><p>automake</p></li><li class="listitem"><p>GCC compiler</p></li></ul></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm46526616709312"></a>Compilation of the Source Code</h3></div></div></div><p>Pull the latest stable version from a git master branch (into a
        directory where you want to store compilation sources, usually it's
        /usr/src/):</p><pre class="programlisting">     cd /usr/src
     git clone -b master https://github.com/sippy/rtpproxy.git</pre><p>Make sure you bring rtpprpoxy git submodules:</p><pre class="programlisting">     git -C rtpproxy submodule update --init --recursive</pre><p>Now compile a binary file using sources using the following
        commands:</p><p>A sequence for users:</p><pre class="programlisting">     cd rtpproxy
     ./configure
     make clean all
     make install</pre><p>For developers might also be useful to include <span class="command"><strong>make
        check</strong></span> in the sequence. Make sure you have <a class="link" href="#deps.libelperiodic">libelperiodic</a>, <a class="link" href="#deps.sudo">sudo</a> and <a class="link" href="#deps.tcpdump">tcpdump</a> installed for that step to
        complete:</p><pre class="programlisting">     cd rtpproxy
     ./configure
     make clean all
     make check
     make install</pre><p>After a successful compilation, you have the following
        binaries</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Main RTP proxy server binary - <span class="bold"><strong>production</strong></span> build.</p><p>After the compilation is done, you have a binary file stored
            in the /usr/local/bin/ folder. You can test this out, checking the
            version of the rtpproxy: <span class="bold"><strong>/usr/local/bin/rtpproxy -V</strong></span></p></li><li class="listitem"><p>Main RTP proxy server binary - <span class="bold"><strong>debug</strong></span> and profiling build.</p><p>You will also have a second binary file for debug and
            profiling: <span class="bold"><strong>/usr/local/bin/rtpproxy_debug</strong></span></p></li></ul></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="idm46526616693792"></a>Chapter 3. Getting Started</h1></div></div></div><div class="highlights"><p>A good way to maintain your RTPProxy is to start it using a
      certain Service Manager, such as systemd.</p><p>Systemd is a latest and the most known Service Manager application
      in most UNIX based systems:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Ubuntu 15.04 is the first version (of Ubuntu) that uses
          systemd by default;</p></li><li class="listitem"><p>Debian 8 (Jessie) is the first version (of Debian) that uses
          systemd by default;</p></li><li class="listitem"><p>Red Hat-based distributions are migrating to systemd as well.
          It has been the default system and services manager in Red Hat 7,
          CentOs7 and Fedora since the release of Fedora 15;</p></li><li class="listitem"><p>There is huge list of other distributions, that use the
          systemd as a System Manager by default now as well (OpenSUSE, Mint,
          Mageia etc.) .</p></li></ul></div></div><p>In case you have a system, that doesn't support the <span class="bold"><strong>systemd</strong></span>, you can use any other Service Managers as
    you want to (for e.g. init.d start scripts in Debian systems older than
    8th one).</p><p>Link to an <span class="bold"><strong>init.d start/stop
    script</strong></span>: <a class="ulink" href="https://link.here.com" target="_top">https://link.here.com</a> (TO DO)</p><p>But, as it was said that the systemd is the most relevant solution
    for this, because it provides the following capabilities:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Define a list of options in a separate environment file, and use
        those options as a variable in the start row 'ExecStart='</p></li><li class="listitem"><p>You're able to react on a failure of an application using a
        special parameter 'OnFailure=' (and to send notification for
        e.g.)</p></li><li class="listitem"><p>You can specify a list of pre-actions to be performed, before
        systemd launches binary file 'ExecStartPre=' (for e.g. creation of
        /var/run/rtproxy directory and adding user/group rights to it)</p></li><li class="listitem"><p>As well as you can add pre-start actions, you can perform
        post-stop actions for cases when application stops running
        'ExecStopPost=' (for e.g. deletion of the /var/run/rtpproxy
        directory)</p></li><li class="listitem"><p>You can set a policy for cases when application stops improperly
        (not a manual stop of the application), for e.g. restarting always
        with 'Restart=always'</p></li><li class="listitem"><p>You may also want to add a time delay between restart attempts
        with 'RestartSec=5'</p></li><li class="listitem"><p>You can deal with different things related to logging or
        syslogging (for e.g. changing of a name identifier when writing to a
        syslog 'SyslogIdentifier=' or specifying a different logfacility level
        with 'StandardOutput=' and 'StandardError=' )</p></li><li class="listitem"><p>User/Group to be used for running an application</p></li><li class="listitem"><p>and many many other things..</p></li></ul></div><p>The link to an instance of the systemd service file (for the
    RTPProxy): <a class="link" href="#rtpproxy.service"><span class="bold"><strong>systemd
    configuration file instance</strong></span> -&gt; <span class="bold"><strong>Instance of the systemd service file</strong></span></a></p><p>After you downloaded your systemd service file, adjust OPTIONS <a class="link" href="#CL_OPTIONS" title="OPTIONS">parameters</a>.</p><p>Set you own IP address for listening, or leave it with 0.0.0.0
    (manual way)</p><pre class="programlisting">-l 0.0.0.0</pre><p>Set upper bound on number of file descriptors the rtpproxy service
    instance might be using. Rule of thumb is that 4 file descriptors are
    needed for a fully established session (two RTP endpoints and two RTCP
    ones).</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>Make the value reasonably high to match your load expectations in
      terms of number of concurrent sessions but not excessively high, as it
      may cause rtpproxy to fail initialization because operating system
      usually also enforces upper bound on this value that varies from system
      to system:</p></div><pre class="programlisting">-L 4096</pre><p>You may also want to change a port range for opening UDP
    ports:</p><pre class="programlisting">-m &lt;min number&gt; -M &lt;max number&gt;

e.g.: -m 10000 -M 40000</pre><p>Change you log facility level if you want to:</p><pre class="programlisting">-d INFO:&lt;LOG_LOCAL_NUMBER&gt;

e.g.: -d INFO:LOG_LOCAL5
      -d DBUG:LOG_LOCAL5</pre><p>For better view of how to configure your startup line, use a <a class="link" href="#CONFIGURATION" title="Chapter 4. Configuration"><span class="guibutton">Configuration
    section</span>.</a></p><p>After you're done with customizing of your systemd service file for
    RTPProxy, follow this sequence to finish it:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>copy it to the /lib/systemd/system/ directory</p></li><li class="listitem"><p>reload systemd configuration with: </p><pre class="programlisting">bash&gt; sudo systemctl daemon-reload</pre></li><li class="listitem"><p>enable the service: </p><pre class="programlisting">bash&gt; sudo systemctl enable rtpproxy.service</pre></li><li class="listitem"><p>Now you can start your RTPProxy using the commands given
        below</p></li></ul></div><p>Working with a systemd, you may need to know a list of general
    commands to manage with your RTPProxy service, here they are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Start of the service:</p><pre class="programlisting">bash&gt; sudo systemctl start rtpproxy.service</pre></li><li class="listitem"><p>Stop of the service:</p><pre class="programlisting">bash&gt; sudo systemctl stop rtpproxy.service</pre></li><li class="listitem"><p>Restart of the service:</p><pre class="programlisting">bash&gt; sudo systemctl restart rtpproxy.service</pre></li><li class="listitem"><p>Check status of the service:</p><pre class="programlisting">bash&gt; sudo systemctl status rtpproxy.service</pre></li><li class="listitem"><p>Show systemd configuration file of the service:</p><pre class="programlisting">bash&gt; sudo systemctl show rtpproxy.service</pre></li></ul></div><p>To see an output after you started you RTPProxy, or even just to
    keep a track on how it's working, you can use the following
    commands:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Look into a journal:</p><pre class="programlisting">bash&gt; sudo journalctl -xe -u rtpproxy.service</pre></li><li class="listitem"><p>You can configure logging to a separate logfile, to do this,
        follow the manual (or you can use manual logging to a syslog file)
        listed in the:</p><p><a class="link" href="#logsepfile" title="Logging to a separate file"><span class="bold"><strong>Configuration
        section</strong></span> -&gt; <span class="bold"><strong>Logging to a separate
        file</strong></span></a></p></li><li class="listitem"><p>You can see an output of the systemctl tool:</p><pre class="programlisting">bash&gt; sudo systemctl status rtpproxy.service</pre></li></ul></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>Interaction of a SIP proxy server with RTPProxy application is
      supported via</p><p><code class="filename">rtpproxy.sock</code> - control socket created by the
      RTPProxy</p><p><code class="filename">rtpproxy_timeout.sock</code> - a socket for timeout
      notifications created by the SIP proxy</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="CONFIGURATION"></a>Chapter 4. Configuration</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="#idm46526611098480">Command Line Parameters</a></span></dt><dt><span class="section"><a href="#idm46526611093984">Configuration File</a></span></dt><dt><span class="section"><a href="#idm46526611092832">Startup Script</a></span></dt><dt><span class="section"><a href="#idm46526611087184">Logging</a></span></dt></dl></div><p>Historically, primary configuration method for the RTPProxy was done
    via command-line parameters. Starting with version 2.2 certain advanced
    parameters (particularly loadable modules configuration) have been moved
    into configuration file.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526611098480"></a>Command Line Parameters</h2></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm46526611097840"></a>SYNOPSIS</h3></div></div></div><div class="cmdsynopsis"><p><a id="SYNOPSIS"></a><code class="command">rtpproxy</code>  [<code class="option">-?</code>] [<code class="option">-2</code>] [<code class="option">-f</code>] [<code class="option">-v</code>] [<code class="option">-V</code>] [<code class="option">-R</code>] [<code class="option">-l</code>
      <em class="replaceable"><code>addr1[<span class="optional">/addr2</span>]</code></em>] [<code class="option">-6</code>
      <em class="replaceable"><code>addr1[<span class="optional">/addr2</span>]</code></em>] [<code class="option">-s</code>
      <em class="replaceable"><code>ctrl_socket</code></em>] [<code class="option">-t</code>
      <em class="replaceable"><code>tos</code></em>] [<code class="option">-p</code>
      <em class="replaceable"><code>pidfile</code></em>] [<code class="option">-T</code>
      <em class="replaceable"><code>max_ttl</code></em>] [<code class="option">-r</code> <em class="replaceable"><code>rdir</code></em>
       [<code class="option">-S</code>
      <em class="replaceable"><code>sdir</code></em>]] [<code class="option">-L</code>
      <em class="replaceable"><code>nofile_limit</code></em>] [<code class="option">-A</code>
      <em class="replaceable"><code>advaddr1[<span class="optional">/advaddr2</span>]</code></em>] [<code class="option">-m</code>
      <em class="replaceable"><code>min_port</code></em>] [<code class="option">-M</code>
      <em class="replaceable"><code>max_port</code></em>] [<code class="option">-u</code>
      <em class="replaceable"><code>uname[<span class="optional">:gname</span>]</code></em>] [<code class="option">-w</code>
      <em class="replaceable"><code>sock_mode</code></em>] [<code class="option">-F</code>] [<code class="option">-i</code>] [<code class="option">-n</code>
      <em class="replaceable"><code>timeout_socket</code></em>] [<code class="option">-P</code>] [<code class="option">-a</code>] [<code class="option">-d</code>
      <em class="replaceable"><code>log_level[<span class="optional">:log_facility</span>]</code></em>] [<code class="option">-W</code>
      <em class="replaceable"><code>setup_ttl</code></em>]</p></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="CL_OPTIONS"></a>OPTIONS</h3></div></div></div><p>The following command-line parameters are supported:</p><div class="variablelist"><a id="OPTIONS"></a><dl class="variablelist"><dt><span class="term"><code class="option">-?</code></span></dt><dd><p>Show summary of options.</p></dd><dt><span class="term"><code class="option">-2</code></span></dt><dd><p>Send every RTP packet twice in sessions that use low-bitrate
          codecs. Only packets that are smaller than 128 bytes will be sent
          twice. This option can improve audio quality on lossy links.</p></dd><dt><span class="term"><code class="option">-f</code></span></dt><dd><p>rtpproxy will stay in foreground mode if this option is
          set.</p></dd><dt><span class="term"><code class="option">-V</code></span></dt><dd><p>Show version of program.</p></dd><dt><span class="term"><code class="option">-v</code></span></dt><dd><p>Show supported rtpp command protocol revisions.</p></dd><dt><span class="term"><code class="option">-l</code>
        <em class="replaceable"><code>addr1[<span class="optional">/addr2</span>]</code></em></span></dt><dd><p>IPv4 listen IP address(es). You can specify either one or two
          addresses. If two addresses are specified, the rtpproxy will work in
          bridging mode.</p></dd><dt><span class="term"><code class="option">-6</code>
        <em class="replaceable"><code>addr1[<span class="optional">/addr2</span>]</code></em></span></dt><dd><p>IPv6 listen IP address(es). You can specify either one or two
          addresses. If two addresses are specified, the rtpproxy will work in
          bridging mode.</p></dd><dt><span class="term"><code class="option">-s</code>
        <em class="replaceable"><code>ctrl_socket</code></em></span></dt><dd><p>This parameter configures rtpproxy control socket. The control
          socket is used by the call controller for the purpose of creating,
          modifying, and deleting RTP sessions. The control socket can also be
          used to fetch stats from the rtpproxy process, or about specific
          media sessions. Format of <em class="replaceable"><code>ctrl_socket</code></em> is
          &lt;type&gt;:&lt;socket&gt;. Following types are supported:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a id="udp"></a><span class="emphasis"><em>udp:</em></span> Create UDP control socket. In
                this mode rtpproxy will listen on a UDP socket for control
                messages from the call controlle.</p><p>Example: -s udp:127.0.0.1:9000</p><p>IP address can be '*' in which case rtpproxy will listen
                on all local interfaces. If port is omitted then port 22222
                will be used.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>rtpproxy control protocol has no built-in security
                  mechanisms. Make sure that you protect the listening IP and
                  port properly when using rtpproxy with UDP control
                  socket.</p></div></li><li class="listitem"><p><a id="udp6"></a><span class="emphasis"><em>udp6:</em></span> Create IPv6 UDP control
                socket. In this mode rtpproxy will listen on UDP/IPv6 for
                control messages from the SIP Controller.</p><p>Example: -s udp6:::1:9000</p></li><li class="listitem"><p><a id="tcp"></a><span class="emphasis"><em>tcp:</em></span> Create IPv4 TCP control
                socket. In this mode rtpproxy will listen on TCP/IPv4 for
                control messages from the SIP Controller.</p><p>Example: -s tcp:192.168.0.1:9001</p></li><li class="listitem"><p><a id="tcp6"></a><span class="emphasis"><em>tcp6:</em></span> Create IPv6 TCP control
                socket. In this mode rtpproxy will listen on TCP/IPv6 for
                control messages from the SIP Controller.</p><p>Example: -s tcp6:::1:9002</p></li><li class="listitem"><p><a id="unix"></a><span class="emphasis"><em>unix:</em></span> Create UNIX domain socket in
                a datagram-like mode for control interface. In this mode the
                SIP Controller and rtpproxy must be running on the same host.
                This is traditional mode when rtpproxy would close connection
                after processing each command and sending reply.</p><p>Example: -s unix:/var/run/rtpproxy.sock</p></li><li class="listitem"><p><a id="cunix"></a><span class="emphasis"><em>cunix:</em></span> Create UNIX domain socket
                for control interface. In this mode the SIP Controller and
                rtpproxy must be running on the same host. Similar to
                <span class="emphasis"><em>unix:</em></span> above, but the rtpproxy would keep
                control socket open and accept multiple commands via the same
                connection.</p><p>Example: -s cunix:/var/run/rtpproxy.sock</p></li></ul></div><p>Default value is
          <code class="filename">unix:/var/run/rtpproxy.sock</code>.</p></dd><dt><span class="term"><code class="option">-t</code> <em class="replaceable"><code>tos</code></em></span></dt><dd><p>Set ToS (Type of Service) in the outgoing IP header. Default
          value is 0xB8. Setting this parameter to -1 disables setting ToS
          resulting in operating system default ToS being used instead.</p></dd><dt><span class="term"><code class="option">-r</code> <em class="replaceable"><code>rec_dir</code></em></span></dt><dd><p>Directory to write recorded RTP sessions.</p></dd><dt><span class="term"><code class="option">-S</code> <em class="replaceable"><code>spool_dir</code></em></span></dt><dd><p>Spool directory for recording of RTP streams. When the session
          is stopped, the recording will be moved from the spool directory to
          the rec_dir directory as specified by the <code class="option">-r</code>
          option.</p></dd><dt><span class="term"><code class="option">-R</code></span></dt><dd><p>Prevent rtpproxy from recording RTCP when recording RTP.
          rtpproxy records RTCP by default when RTP recording is
          enabled.</p></dd><dt><span class="term"><code class="option">-p</code> <em class="replaceable"><code>pid_file</code></em></span></dt><dd><p>This parameter configures the name of the file where PID of
          running rtpproxy will be stored. Default is
          <code class="filename">/var/run/rtpproxy.pid</code>.</p></dd><dt><span class="term"><code class="option">-T</code> <em class="replaceable"><code>max_ttl</code></em></span></dt><dd><p>Specify the RTP inactivity timer. Defaults to 60
          seconds.</p><p>If the rtpproxy does not receive any RTP packets for more than
          <em class="replaceable"><code>max_ttl</code></em> it will then delete the
          session.</p></dd><dt><span class="term"><code class="option">-L</code>
        <em class="replaceable"><code>nofile_limit</code></em></span></dt><dd><p>Set the maximum number of open file descriptors per process.
          The default maximum is set by the operating system, and can be
          overridden using the <code class="option">-L</code> flag.</p><p>The rtpproxy requires four file descriptors per session to
          ensure that it can reliably identify where each stream is coming
          from in a NAT firewall scenario.</p></dd><dt><span class="term"><code class="option">-A</code>
        <em class="replaceable"><code>advaddr1[<span class="optional">/advaddr2</span>]</code></em></span></dt><dd><p>Set advertised address of rtpproxy. Useful if the rtpproxy is
          behind a NAT firewall. (Amazon EC2) When the rtpproxy receives a
          session request from a SIP controller it will return the IP
          address(es) specified by the <code class="option">-A</code> option.</p></dd><dt><span class="term"><code class="option">-m</code> <em class="replaceable"><code>min_port</code></em></span></dt><dd><p>Set lower limit on UDP ports range that the rtpproxy uses for
          RTP/RTCP sessions to <em class="replaceable"><code>min_port</code></em>. Default is
          35000.</p></dd><dt><span class="term"><code class="option">-M</code> <em class="replaceable"><code>max_port</code></em></span></dt><dd><p>Set upper limit on UDP ports range that the rtpproxy uses for
          RTP/RTCP sessions to <em class="replaceable"><code>max_port</code></em>. Default is
          65000.</p></dd><dt><span class="term"><code class="option">-u</code>
        <em class="replaceable"><code>uname[<span class="optional">:gname</span>]</code></em></span></dt><dd><p>Switch rtpproxy to UID identified by the
          <em class="replaceable"><code>uname</code></em> and optional GID identified by
          <em class="replaceable"><code>gname</code></em> when proxy is up and
          running.</p></dd><dt><span class="term"><code class="option">-w</code> <em class="replaceable"><code>sock_mode</code></em></span></dt><dd><p>Set access mode for the controlling UNIX-socket (if used).
          Only applies if rtpproxy runs under a different GID using
          <code class="option">-u</code> option.</p></dd><dt><span class="term"><code class="option">-F</code></span></dt><dd><p>By default the rtpproxy will warn user if running as superuser
          (UID 0) in local control mode and refuse to run in remote control
          mode at all. This switch removes the check.</p></dd><dt><span class="term"><code class="option">-i</code></span></dt><dd><p>Enable independent RTP activity timeout mode. By default, a
          timeout (which results in automatic destruction of the session) can
          only occur if no RTP packets are received on any of the session's
          ports. This option, if set, varies that behaviour, such that a
          timeout will occur if packets are still being received on one port
          but not the other. The option should be used with caution since in
          some cases it's perfectly fine to have packets coming from only one
          side of conversation (i.e. when the second party has muted its
          audio).</p></dd><dt><span class="term"><code class="option">-n</code>
        <em class="replaceable"><code>timeout_socket</code></em></span></dt><dd><p>This parameter specifies permitted notification sockets only.
          The listening socket must be created by another application,
          preferably before starting rtpproxy.</p><p>Timeout notifications must be enabled by the SIP controller
          when setting up the session. The SIP Controller must specify the
          timeout_socket, and a notify_tag, which is expected to be an
          arbitrary string that can be used by the SIP controller to identify
          which session a received time out notification relates to.</p><p>If a SIP Controller specifies a notification socket for a
          session, and that socket is not specified using the
          <code class="option">-n</code> flag, the rtpproxy will not send a notification,
          and will not produce an error. It will ignore the notification
          request.</p><p>Format of <em class="replaceable"><code>timeout_socket</code></em> is
          &lt;type&gt;:&lt;socket&gt;. Following types are supported:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>unix:</em></span> Connect to UNIX domain socket
                for sending timeout notifications. In this mode B2BUA and
                rtpproxy must be running on the same host.</p><p>Example: -n unix:/var/run/rtpproxy_timeout.sock</p></li><li class="listitem"><p><span class="emphasis"><em>tcp:</em></span> Connect to a remote host using
                TCP/IP for sending timeout notifications. Format of the
                <em class="replaceable"><code>socket</code></em> parameter in this case is
                &lt;host&gt;:&lt;port&gt;.</p><p>Example: -n tcp:10.20.30:12345</p></li></ul></div><p>There is no default value, notifications are not sent and not
          permitted unless a value is specified explicitly. Multiple
          notification sockets can be provided by specifying the
          <code class="option">-n</code> flag more than once.</p></dd><dt><span class="term"><code class="option">-P</code></span></dt><dd><p>Record sessions using libpcap file format instead of
          non-standard ad-hoc format. The libpcap format, which is the
          de-facto standard for packet capturing software, has the advantage
          of being compatible with numerous third-party tools and utilities,
          such as tcpdump or Wireshark. The drawback of libpcap is slightly
          larger overhead (extra 12 bytes for every saved RTP packet for
          IPv4).</p></dd><dt><span class="term"><code class="option">-a</code></span></dt><dd><p>Record all sessions going through the rtpproxy
          unconditionally. By default rtpproxy expects the SIP controller to
          enable recording on a per-session basis.</p></dd><dt><span class="term"><code class="option">-d</code>
        <em class="replaceable"><code>log_level[<span class="optional">:log_facility</span>]</code></em></span></dt><dd><p>Configures the verbosity level of the log output. Possible
          <em class="replaceable"><code>log_level</code></em> values in the order from the
          most verbose to the least verbose are: DBUG, INFO, WARN, ERR and
          CRIT.</p><p>The optional <em class="replaceable"><code>log_facility</code></em> parameter
          sets syslog(3) facility assigned to log messages.</p><p>Example: -d WARN:LOG_LOCAL5</p><p>The default level in foreground mode is is DBUG, in background
          - WARN and facility is LOG_DAEMON.</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526611093984"></a>Configuration File</h2></div></div></div><p>TODO</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526611092832"></a>Startup Script</h2></div></div></div><p>The way you integrate RTPProxy into your system startup sequence
      is highly OS-version dependent. If you are using per-built RTPProxy
      package then most likely such method will be provided as part of that
      package and the best course of actions is to use that facility.</p><p>However, if you are a package maintainer or system builder you
      might need to create such configuration from scratch. In the next
      sections we would provide some basic guidelines on how to launch
      RTPProxy in some common cases.</p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm46526611090864"></a>Systemd based systems</h3></div></div></div><p>On most modern Linux-based systems
        <span class="application">systemd</span> is the recommended method to start
        the RTPProxy.</p><a id="rtpproxy.service"></a><pre class="programlisting">[Unit]
Description=RTPProxy media server
After=network.target
Requires=network.target

[Service]
Type=simple
PIDFile=/var/run/rtpproxy/rtpproxy.pid
Environment='OPTIONS= -f -L 4096 -l 0.0.0.0 -m 10000 -M 20000 -d INFO:LOG_LOCAL5'

Restart=always
RestartSec=5

ExecStartPre=-/bin/mkdir /var/run/rtpproxy
ExecStartPre=-/bin/chown rtpproxy:rtpproxy /var/run/rtpproxy

ExecStart=/usr/local/bin/rtpproxy -p /var/run/rtpproxy/rtpproxy.pid -s unix:/var/run/rtpproxy/rtpproxy.sock \
 -u rtpproxy rtpproxy -n unix:/var/run/rtpproxy/rtpproxy_timeout.sock $OPTIONS
ExecStop=/usr/bin/pkill -F /var/run/rtpproxy/rtpproxy.pid

ExecStopPost=-/bin/rm -R /var/run/rtpproxy

StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=rtpproxy
SyslogFacility=local5

TimeoutStartSec=10
TimeoutStopSec=10

[Install]
WantedBy=multi-user.target</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm46526611087184"></a>Logging</h2></div></div></div><p>Logging is a very important aspect of the RTPProxy operation that
      should not be overlooked. In our experience, properly configured and
      tested RTPProxy instance can keep running unattended literally for many
      years non-stop. Yet, various issues with a particular session and/or
      endpoint would inevitably pop-up over time, so it's of utter importance
      to setup logging and log management in a manner that is durable and
      forward-looking. Allowing someone to perform a post-mortem investigation
      of particular issue that happened days, if not weeks, ago with a
      relative ease.</p><p>Some of the consideration one should have in mind while
      configuring logging is:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>How much storage my system has for the RTPProxy to use?</p></li><li class="listitem"><p>What is the typical amount of time it takes for my user to
          report an issue and get it escalated to the DevOps team?</p></li><li class="listitem"><p>What is the typical amount of time it takes for the DevOps
          team to act on issue and look at the logs in question?</p></li><li class="listitem"><p>How much detail do I need? The answer to this might depends on
          whether this is a development/QA or a production system.</p></li><li class="listitem"><p>Are there any other non-technical consideration that might
          influence those decisions? For example: data protection laws, law
          enforcement requirements etc.</p></li></ol></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="logsepfile"></a>Logging to a separate file</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>First of all you need to create a file you will use for
            logging and give it proper permissions (according to a user/group
            starting RTPProxy):</p><pre class="programlisting">touch /var/log/rtpproxy.log
chown rtpproxy:rtpproxy /var/log/rtpproxy.log</pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Then define a log facility for it in rsyslog configuration
            file (add a row at the bottom of the file) and restart rsyslog
            server:</p><pre class="programlisting">vim /etc/rsyslog.d/50-default.conf
 local5.*        /var/log/rtpproxy.log

systemctl restart rsyslog.service</pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>next step add a log rotation configuration for this log file
            (that's a good way of handling overfilled log files):</p><pre class="programlisting">vim /etc/logrotate.d/rtpproxy</pre><pre class="programlisting">/var/log/rtpproxy.log {
  missingok
  compress
  delaycompress
  notifempty
  copytruncate
  rotate 5
  daily
}</pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Now add a log facility level to your start row of the
            RTPProxy:</p><pre class="programlisting">-d INFO:LOG_LOCAL5</pre></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Reload systemd configuration (to apply previous change) and
            restart your RTPProxy server. Now logging should be done using new
            output file:</p><pre class="programlisting">systemctl daemon reload

systemctl restart rtpproxy.service</pre></li></ul></div><p></p></div></div></div></div></body></html>